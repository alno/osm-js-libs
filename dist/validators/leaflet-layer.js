// Generated by CoffeeScript 1.3.1
(function() {
  var Layer;

  Layer = L.Class.extend({
    includes: L.Mixin.Events,
    initialize: function(options) {
      var validator, _i, _len, _ref, _results;
      this.options = options != null ? options : {};
      this.layers = {};
      this.validators = {};
      this.limitedUpdate = L.Util.limitExecByInterval(this.update, 3000, this);
      if (this.options.validators) {
        _ref = this.options.validators;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          validator = _ref[_i];
          _results.push(this.addValidator(validator));
        }
        return _results;
      }
    },
    addValidator: function(validator) {
      if (this.validators[validator.url]) {
        this.validators[validator.url] = validator;
        if (this.map) {
          this.updateValidator(validator);
        }
        return this.fire('validatorchange', {
          validator: validator
        });
      } else {
        this.layers[validator.url] = new L.LayerGroup();
        this.validators[validator.url] = validator;
        if (this.map) {
          this.map.addLayer(this.layers[validator.url]);
          this.updateValidator(validator);
        }
        return this.fire('validatoradd', {
          validator: validator
        });
      }
    },
    removeValidator: function(validator) {
      if (this.validators[validator.url]) {
        if (this.map) {
          this.map.removeLayer(this.layers[validator.url]);
        }
        this.layers[validator.url] = void 0;
        this.validators[validator.url] = void 0;
        return this.fire('validatorremove', {
          validator: validator
        });
      }
    },
    onAdd: function(map) {
      var key, layer, _ref;
      this.map = map;
      _ref = this.layers;
      for (key in _ref) {
        layer = _ref[key];
        map.addLayer(layer);
      }
      map.on('moveend', this.update, this);
      return this.update();
    },
    onRemove: function(map) {
      var key, layer, _ref;
      map.off('moveend', this.update, this);
      _ref = this.layers;
      for (key in _ref) {
        layer = _ref[key];
        map.removeLayer(layer);
      }
      return this.map = void 0;
    },
    update: function() {
      var url, validator, _ref, _results;
      Layer.Utils.cancelRequests();
      _ref = this.validators;
      _results = [];
      for (url in _ref) {
        validator = _ref[url];
        _results.push(this.updateValidator(validator));
      }
      return _results;
    },
    updateValidator: function(validator) {
      var bounds, ne, sw, url,
        _this = this;
      bounds = this.map.getBounds();
      sw = bounds.getSouthWest();
      ne = bounds.getNorthEast();
      url = validator.url.replace('{minlat}', sw.lat).replace('{maxlat}', ne.lat).replace('{minlon}', sw.lng).replace('{maxlon}', ne.lng);
      return Layer.Utils.request(url, validator, function(data) {
        var layer, res, _i, _len, _ref;
        layer = _this.layers[validator.url];
        map.removeLayer(layer);
        layer.clearLayers();
        _ref = data.results;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          res = _ref[_i];
          layer.addLayer(_this.buildResult(validator, res));
        }
        return map.addLayer(layer);
      });
    },
    buildResult: function(validator, res) {
      var bounds, center, errorText, ne, obj, popupText, resLayer, sw, _i, _len, _ref;
      bounds = new L.LatLngBounds();
      resLayer = new L.GeoJSON({
        type: 'Feature',
        geometry: res.geometry
      });
      resLayer._iterateLayers((function(l) {
        return bounds.extend(l instanceof L.Marker ? l.getLatLng() : l.getBounds());
      }), resLayer);
      center = bounds.getCenter();
      sw = bounds.getSouthWest();
      ne = bounds.getNorthEast();
      errorText = res.text || validator.types[res.type].text;
      popupText = "<p>" + errorText + "</p>";
      if (res.objects) {
        popupText += "<ul>";
        _ref = res.objects;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          obj = _ref[_i];
          popupText += "<li><a href=\"http://www.openstreetmap.org/browse/" + obj[0] + "/" + obj[1] + "\" target=\"_blank\">" + (obj.join('-')) + "</a></li>";
        }
        popupText += "</ul>";
      }
      popupText += "<p>";
      popupText += "<a href=\"http://localhost:8111/load_and_zoom?top=" + ne.lat + "&bottom=" + sw.lat + "&left=" + sw.lng + "&right=" + ne.lng + "\" target=\"josm\">Edit in JOSM</a><br />";
      popupText += "<a href=\"http://openstreetmap.org/edit?lat=" + center.lat + "&lon=" + center.lng + "&zoom=17\" target=\"_blank\">Edit in Potlatch</a><br />";
      popupText += "</p>";
      resLayer.bindPopup(popupText);
      return resLayer;
    }
  });

  Layer.Utils = {
    callbacks: {},
    callbackCounter: 0,
    activeXhr: [],
    activeJsonp: [],
    cancelRequests: function() {
      var el, xhr, _i, _j, _len, _len1, _ref, _ref1;
      _ref = this.activeXhr;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        xhr = _ref[_i];
        xhr.abort();
      }
      _ref1 = this.activeJsonp;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        el = _ref1[_j];
        el.src = void 0;
        document.getElementsByTagName('body')[0].removeChild(el);
      }
      this.activeXhr = [];
      return this.activeJsonp = [];
    },
    request: function(url, validator, cb) {
      if (validator.jsonp) {
        return this.requestJsonp(url, cb);
      } else {
        return this.requestXhr(url, cb);
      }
    },
    requestXhr: function(url, cb) {
      var xhr;
      xhr = new XMLHttpRequest();
      xhr.open('GET', url, true);
      xhr.onreadystatechange = function() {
        var idx;
        if (xhr.readyState === 4) {
          if (xhr.status === 200) {
            if ((idx = this.activeXhr.indexOf(xhr)) >= 0) {
              this.activeXhr.splice(idx, 1);
            }
            return cb(eval("(" + xhr.responseText + ")"));
          }
        }
      };
      xhr.send();
      return this.activeXhr.push(xhr);
    },
    requestJsonp: function(url, cb) {
      var callback, counter, delim, el,
        _this = this;
      el = document.createElement('script');
      counter = (this.callbackCounter += 1);
      callback = "OsmJs.Validators.LeafletLayer.Utils.callbacks[" + counter + "]";
      this.callbacks[counter] = function(data) {
        var idx;
        if ((idx = _this.activeJsonp.indexOf(el)) >= 0) {
          _this.activeJsonp.splice(idx, 1);
          document.getElementsByTagName('body')[0].removeChild(el);
          _this.callbacks[counter] = void 0;
          return cb(data);
        }
      };
      delim = url.indexOf('?') >= 0 ? '&' : '?';
      el.src = "" + url + delim + "callback=" + callback;
      document.getElementsByTagName('body')[0].appendChild(el);
      return this.activeJsonp.push(el);
    }
  };

  if (!this.OsmJs) {
    this.OsmJs = {};
  }

  if (!this.OsmJs.Validators) {
    this.OsmJs.Validators = {};
  }

  this.OsmJs.Validators.LeafletLayer = Layer;

}).call(this);
